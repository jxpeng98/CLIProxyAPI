name: Sync with Upstream

on:
  schedule:
    - cron: "0 0,12 * * *"
  workflow_dispatch:

permissions:
  contents: write
  pull-requests: write
  issues: write

jobs:
  check-upstream:
    runs-on: ubuntu-latest

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          token: ${{ secrets.GITHUB_TOKEN }}

      - name: Configure Git
        run: |
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"

      - name: Detect upstream (fork only)
        id: upstream
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          set -euo pipefail

          is_fork=$(gh api "repos/${{ github.repository }}" --jq '.fork')
          echo "is_fork=$is_fork" >> "$GITHUB_OUTPUT"

          if [ "$is_fork" != "true" ]; then
            echo "Not a fork repository. Skip upstream sync."
            echo "upstream_url=" >> "$GITHUB_OUTPUT"
            exit 0
          fi

          upstream_url=$(gh api "repos/${{ github.repository }}" --jq '.parent.clone_url')
          if [ -z "${upstream_url:-}" ] || [ "$upstream_url" = "null" ]; then
            echo "Unable to detect upstream URL."
            exit 1
          fi

          echo "upstream_url=$upstream_url" >> "$GITHUB_OUTPUT"
          echo "Upstream URL: $upstream_url"

      - name: Add upstream remote and fetch tags
        if: steps.upstream.outputs.is_fork == 'true'
        run: |
          set -euo pipefail

          git remote add upstream "${{ steps.upstream.outputs.upstream_url }}" 2>/dev/null || \
            git remote set-url upstream "${{ steps.upstream.outputs.upstream_url }}"

          git fetch upstream --prune --tags --force

      - name: Check for new upstream tags (vX.Y.Z only)
        if: steps.upstream.outputs.is_fork == 'true'
        id: check_tags
        run: |
          set -euo pipefail

          latest_upstream_tag=$(
            git ls-remote --tags upstream \
              | awk '{print $2}' \
              | sed 's#refs/tags/##' \
              | grep -v '\^{}' \
              | grep -E '^v[0-9]+\.[0-9]+\.[0-9]+$' \
              | sort -V -r \
              | head -n 1 || true
          )

          if [ -z "${latest_upstream_tag:-}" ]; then
            latest_upstream_tag="none"
          fi

          echo "Latest upstream tag: $latest_upstream_tag"

          if [ -f .github/sync-upstream-tag ]; then
            last_synced_tag="$(cat .github/sync-upstream-tag || true)"
          else
            last_synced_tag="none"
          fi

          echo "Last synced tag: $last_synced_tag"

          if [ "$latest_upstream_tag" != "none" ] && [ "$latest_upstream_tag" != "$last_synced_tag" ]; then
            echo "new_tag_found=true" >> "$GITHUB_OUTPUT"
            echo "latest_tag=$latest_upstream_tag" >> "$GITHUB_OUTPUT"
          else
            echo "new_tag_found=false" >> "$GITHUB_OUTPUT"
          fi

      - name: Create sync branch (merge tag commit) and PR
        if: steps.upstream.outputs.is_fork == 'true' && steps.check_tags.outputs.new_tag_found == 'true'
        shell: bash
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          set -euo pipefail

          latest_tag="${{ steps.check_tags.outputs.latest_tag }}"
          branch_name="sync-upstream-${latest_tag}"

          git fetch origin main --prune
          git checkout -B "$branch_name" "origin/main"

          # 确保拿到该 tag
          git fetch upstream "refs/tags/${latest_tag}:refs/tags/${latest_tag}" --force

          # tag -> commit（兼容 annotated tag）
          tag_commit="$(git rev-list -n 1 "refs/tags/${latest_tag}")"
          echo "Tag ${latest_tag} -> commit ${tag_commit}"

          # 合并 tag 指向的 commit 到分支（最终通过 PR 合并进 main）
          git merge --no-ff --no-edit "$tag_commit" -m "Merge upstream ${latest_tag} (${tag_commit}) into main"

          # 记录已同步 tag（仅记录，不同步 tag 到仓库）
          mkdir -p .github
          echo "$latest_tag" > .github/sync-upstream-tag
          git add .github/sync-upstream-tag
          git commit -m "Record synced upstream tag ${latest_tag}" --allow-empty

          git push --force origin "$branch_name"

          # 尝试创建 label（失败不阻塞流程）
          label_available=false
          if gh label list --json name --jq '.[].name' 2>/dev/null | grep -qx "upstream-sync"; then
            label_available=true
          else
            if gh label create "upstream-sync" --description "Automated upstream sync PRs" --color "BFDADC" 2>/dev/null; then
              label_available=true
            else
              echo "::warning::Unable to create 'upstream-sync' label (permission denied or already exists). PR will be created without label."
            fi
          fi

          # PR body：用 printf 生成，避免 YAML/编辑器误解析多行内容
          pr_body="$(printf '%s\n%s\n%s\n%s\n%s\n' \
            '## Upstream Sync' \
            '' \
            "This PR merges the commit pointed to by upstream tag \`${latest_tag}\` into \`main\`." \
            "- Upstream tag: \`${latest_tag}\`" \
            "- Tag commit: \`${tag_commit}\`")"

          # 显式指定仓库，确保 PR 创建在自己的 fork 而不是 upstream
          repo="${{ github.repository }}"

          existing_pr="$(gh pr list --repo "$repo" --state open --head "$branch_name" --base main --json number --jq '.[0].number' || true)"
          if [ -n "${existing_pr:-}" ] && [ "${existing_pr:-}" != "null" ]; then
            echo "PR #$existing_pr already exists for $branch_name."
          else
            # 根据 label 是否可用决定是否添加 --label 参数
            if [ "$label_available" = "true" ]; then
              gh pr create \
                --repo "$repo" \
                --title "Sync upstream ${latest_tag}" \
                --body "$pr_body" \
                --base main \
                --head "$branch_name" \
                --label "upstream-sync"
            else
              gh pr create \
                --repo "$repo" \
                --title "Sync upstream ${latest_tag}" \
                --body "$pr_body" \
                --base main \
                --head "$branch_name"
            fi

            # 获取刚创建的 PR 编号
            new_pr="$(gh pr list --repo "$repo" --state open --head "$branch_name" --base main --json number --jq '.[0].number' || true)"
            if [ -n "${new_pr:-}" ] && [ "${new_pr:-}" != "null" ]; then
              echo "Checking PR #$new_pr for conflicts..."
              
              # 等待 GitHub 计算 mergeable 状态（最多等待 30 秒）
              for i in {1..6}; do
                mergeable="$(gh pr view "$new_pr" --repo "$repo" --json mergeable --jq '.mergeable' 2>/dev/null || echo "UNKNOWN")"
                if [ "$mergeable" != "UNKNOWN" ]; then
                  break
                fi
                echo "Waiting for mergeable status... ($i/6)"
                sleep 5
              done
              
              if [ "$mergeable" = "CONFLICTING" ]; then
                echo "::error::PR #$new_pr has merge conflicts! Please resolve conflicts manually."
                echo "::warning::Upstream tag ${latest_tag} could not be auto-merged due to conflicts."
              elif [ "$mergeable" = "MERGEABLE" ]; then
                echo "No conflicts detected. Enabling auto-merge for PR #$new_pr..."
                gh pr merge "$new_pr" --repo "$repo" --auto --squash || echo "::warning::Failed to enable auto-merge. You may need to enable it in repo settings or merge manually."
              else
                echo "::warning::Unable to determine mergeable status (status: $mergeable). Skipping auto-merge."
              fi
            fi
          fi